from enum import Enum
from typing import List

class SqlDialect(Enum):
    SQLITE = 'sqlite'
    POSTGRES = 'postgresql'
    MYSQL = 'mysql'

data_type_map = {
    'blob' : {
        SqlDialect.SQLITE: 'blob',
        SqlDialect.POSTGRES: 'bytea',
        SqlDialect.MYSQL: 'blob',
    },
    'tinyint': {
        SqlDialect.SQLITE: 'tinyint',
        SqlDialect.POSTGRES: 'smallint',
        SqlDialect.MYSQL: 'smallint'
    },
    'text-as-index': {
        SqlDialect.SQLITE: 'text',
        SqlDialect.POSTGRES: 'text',
        SqlDialect.MYSQL: 'varchar(255)'
    }
}
def data_type(data_type: str, dialect: str):
    return data_type_map[data_type][SqlDialect(dialect)]

clause_map = {
    'AUTOINCREMENT': {
        SqlDialect.SQLITE: 'AUTOINCREMENT',
        SqlDialect.POSTGRES: 'GENERATED BY DEFAULT AS IDENTITY',
        SqlDialect.MYSQL: 'AUTO_INCREMENT'
    },
    'INDEXED BY': {
        SqlDialect.SQLITE: 'INDEXED BY',
        SqlDialect.POSTGRES: '', # postgres does not allow index hinting
        SqlDialect.MYSQL: 'USE INDEX'
    },
    'CREATE INDEX IF NOT EXISTS': {
        SqlDialect.SQLITE: 'CREATE INDEX IF NOT EXISTS',
        SqlDialect.POSTGRES: 'CREATE INDEX IF NOT EXISTS',
        SqlDialect.MYSQL: 'CREATE INDEX'
    },
}
def clause(clause: str, dialect: str):
    return clause_map[clause][SqlDialect(dialect)]


def upsert_query(table_name: str, primary_key_columns: List[str], columns: List[str], dialect: str):
    query_param_columns = map(lambda v: ':' + v, columns)
    
    if SqlDialect(dialect) == SqlDialect.SQLITE:
        return f"INSERT OR REPLACE INTO {table_name} VALUES({', '.join(query_param_columns)})"

    elif SqlDialect(dialect) == SqlDialect.POSTGRES:
        set_statements = _generate_set_statements(primary_key_columns, columns)
        return (
             f"INSERT INTO {table_name}({', '.join(columns)}) VALUES({', '.join(query_param_columns)}) "
             f"ON CONFLICT ({', '.join(primary_key_columns)}) "
             f"DO UPDATE SET {', '.join(set_statements)}"
         )

    elif SqlDialect(dialect) == SqlDialect.MYSQL:
        set_statements = _generate_set_statements(primary_key_columns, columns)
        return (
             f"INSERT INTO {table_name}({', '.join(columns)}) VALUES({', '.join(query_param_columns)}) "
             "ON DUPLICATE KEY UPDATE "
             f"{', '.join(set_statements)}"
         )

    else:
        raise Exception("Invalid or unsupported sql dialect")

def _generate_set_statements(primary_key_columns: List[str], columns: List[str]):
    set_statements = []
    for col in columns:
        if col not in primary_key_columns:
            set_statements.append(f"{col} = :{col}")
    return set_statements